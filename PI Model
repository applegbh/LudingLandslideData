Algorithm 1: Integrate_Heim_with_Machine_Learning
    Input: su_polygons, dem_data, landscape_data, ml_model
    Output: trained_model
    
    // Module 1: Extract physical features from Heim energy line model (Section 3.1)
    physical_features ← empty list
    for each su in su_polygons do
        // Calculate vertical height difference of SU (Formula 1)
        travel_h ← Calculate_Travel_Height(su, dem_data)
        // Calculate horizontal distance of SU (Section 2.3.2)
        travel_dis ← Calculate_Travel_Distance(su)
        // Calculate travel angle (α = arctan(ΔH / L), Formula 1)
        travel_ang ← Arctangent(travel_h / travel_dis)
        // Calculate material velocity via Heim model (Formulas 2-5)
        velocity ← Calculate_Velocity(travel_h, travel_dis, su.slope)
        // Append physical feature vector
        physical_features.append([travel_h, travel_dis, travel_ang, velocity])
    end for
    
    // Module 2: Merge physical features with landscape features (Section 3.2)
    combined_features ← Merge_Features(physical_features, landscape_data)
    
    if ml_model == "PIETtree" then
        trained_model ← Train_PIETree(combined_features, labels)
    else if ml_model == "PIXGB" then
        trained_model ← Train_PIXGB(combined_features, labels)
    else if ml_model == "PIRF" then
        trained_model ← Train_PIRF(combined_features, labels)
    else if ml_model == "PIGAM" then
        trained_model ← Train_PIGAM(combined_features, labels)
    end if
    
    return trained_model


// Subfunction 1: Calculate SU vertical height difference
function Calculate_Travel_Height(su, dem_data)
    // Query max and min elevation within SU polygon
    max_elev ← Get_Max_Elevation(su.polygon, dem_data)
    min_elev ← Get_Min_Elevation(su.polygon, dem_data)
    return max_elev - min_elev


// Subfunction 2: Calculate SU horizontal travel distance
function Calculate_Travel_Distance(su)
    // Get highest point and farthest point in SU polygon
    highest_point ← su.polygon.Get_Highest_Point()
    farthest_point ← su.polygon.Get_Farthest_Point(highest_point)
    return Euclidean_Distance(highest_point, farthest_point)

// Subfunction 3: Calculate velocity via Heim energy line model
function Calculate_Velocity(travel_h, travel_dis, slope)
    // Implement Formulas 2-5: v = √(2k_i g), k_i from energy line model
    alpha ← Arctangent(travel_h / travel_dis)  // Formula 1
    Q_max ← travel_h  // Assume max height is Q_max
    L_prime ← travel_dis  // Horizontal distance from top
    k_i ← Q_max - L_prime * Tangent(alpha)  // Formulas 3-5
    g ← 9.8  // Gravitational acceleration (m/s²)
    return Sqrt(2 * g * k_i)

// Subfunction 4: Merge physical and landscape features
function Merge_Features(physical_features, landscape_data)
    // Ensure spatial alignment of features
    merged_data ← empty matrix
    for i from 0 to len(physical_features)-1 do
        // Get landscape features by spatial index
        landscape_sample ← landscape_data.Get_Sample_by_Index(i)
        // Concatenate physical and landscape features
        merged_sample ← Concatenate(physical_features[i], landscape_sample)
        merged_data.append(merged_sample)
    end for
    return merged_data
